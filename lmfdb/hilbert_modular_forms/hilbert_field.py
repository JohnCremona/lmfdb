# -*- coding: utf-8 -*-
r""" Class for interface with the 'field' component of the Hilbert Modular Form database.

Initial version (University of Warwick 2015) Aurel Page and John Cremona

"""

from sage.all import ZZ
from lmfdb.base import app, getDBConnection
from lmfdb.WebNumberField import WebNumberField

hmf_nfdb = None


def db_hmfnf():
    """
    Return the fields collection from the HMF database
    """
    global hmf_nfdb
    if hmf_nfdb is None:
        hmf_nfdb = getDBConnection().hmfs.fields
    return hmf_nfdb

def findvar(L):
    """
    Return the variable name from a collection of objects
    """
    for x in L:
        for c in x:
            if c.isalpha():
                return c.encode()
    return None

def str2fieldelt(F,strg):
    """Given a string strg representing an element of the number field F
    as a polynomial in its generator, return the number field element.

    F is the number field (in the correct variable)

    strg is a string representing an element of F
    """
    return F(strg.encode())

def str2ideal(F,strg):
    """Given a string strg representing an ideal of the number field F,
    return (N,n,I,gen) where I is the ideal, N its norm, n the least
    positive integer in I and gen a second generator.

    F is the number field (in the correct variable)

    strg is a string representing an ideal of F in the form '[N,n,gen]'
    """
    idlstr = strg[1:-1].replace(' ','').split(',')
    N = ZZ(idlstr[0]) #norm
    n = ZZ(idlstr[1]) #smallest integer
    gen = str2fieldelt(F,idlstr[2]) #other generator
    idl = F.ideal(n,gen)
    return N,n,idl,gen

def niceideals(F, ideals): #HNF + sage ideal + label
    """Convert a list of ideas from strongs to actual NumberField ideals

    F is a Sage NumberField

    ideals is a list of strings representing ideals I in the field, of
    the form [N,a,alpha] where N is the norm of I, a the least
    positive integer in I, and alpha a field element such that I is
    generated by a and alpha.

    The output is a list

    """
    nideals = []
    ilabel = 1
    norm = ZZ(0)
    for i in range(len(ideals)):
        N,n,idl,_ = str2ideal(F,ideals[i])
        assert idl.norm() == N and idl.smallest_integer() == n
        if N != norm:
            ilabel = ZZ(1)
            norm = N
        label = N.str() + '.' + ilabel.str()
        hnf = idl.pari_hnf().python()
        nideals.append([hnf, idl, label])
        ilabel += 1
    return nideals

def conjideals(ideals, auts): #(label,g) -> label
    cideals = {}
    from copy import copy
    ideals = copy(ideals)
    ideals.sort()
    for ig,g in enumerate(auts):
        gideals = copy(ideals)
        for I in gideals:
            I[0] = g(I[1]).pari_hnf().python()
        gideals.sort()
        for I,J in zip(ideals,gideals):
            cideals[(J[2],ig)] = I[2]
    return cideals



class HilbertNumberField(WebNumberField):
    """Subclass of WebNumberField which also facilitates extraction of
    the number field data stored in the Hilbert Modular Forms
    database, or from a data file.  Also allows storing into the
    database, so it can be used to read from a file and then store the
    result.
    """
    def __init__(self, label=None, filename=None):
        r"""
        If label is not None it initialises from the database.

        Otherwise, if filename is not None, it reads from a data file
        (in the format described in hmf_data_format.txt).

        Otherwise, an error is raised.
        """
        if label:
            self.init_from_label(label)
        else:
            if filename:
                self.init_from_file(filename)
            else:
                raise ValueError("either label or filename must be specified to create a HilbertNumberField")


    def init_from_label(self, label):
        print("Creating HilbertNumberField from label %s" % label)
        self.label = label
        self.Fdata = db_hmfnf().find_one({'label':label})
        if not self.Fdata:
            raise ValueError("No Hilbert field with label %s exists in the database" % label)
        self.ideals = self.Fdata['ideals']
        self.primes = self.Fdata['primes']
        self.var = findvar(self.ideals)
        WebNumberField.__init__(self,label,gen_name=self.var)
        print("Setting up look-up tables for primes, ideals and their labels")
        self.prime_norms = [I['ideal'].norm() for I in self.primes_iter()]
        self.ideal_norms = [I['ideal'].norm() for I in self.ideals_iter()]
        self.ideal_dict = {}
        self.label_dict = {}
        self.ideal_index_dict = {}
        self.prime_index_dict = {}
        for i, I in enumerate(self.ideals_iter()):
            self.ideal_dict[I['label']]=I['ideal']
            self.label_dict[I['ideal']]=I['label']
            self.ideal_index_dict[I['ideal']]=i
        self.prime_index_dict = {}
        for i, I in enumerate(self.primes_iter()):
            self.prime_index_dict[I['ideal']]=i

    def ideal_from_str(self, idlstr):
        return str2ideal(self.K(),idlstr)

    def _iter_ideals(self, primes=False, number=None):
        """
        Iterator through all ideals of self.  Delivers dicts with keys
        'label' and 'ideal'.
        """
        count = 0
        ilabel = 1
        norm = ZZ(0)
        ideals = self.ideals
        if primes:
            ideals = self.primes
        for idlstr in ideals:
            N,n,idl,_ = self.ideal_from_str(idlstr)
            assert idl.norm() == N and idl.smallest_integer() == n
            if N != norm:
                ilabel = ZZ(1)
                norm = N
            label = N.str() + '.' + ilabel.str()
            yield {'label':label, 'ideal':idl}
            ilabel += 1
            count += 1
            if count==number:
                raise StopIteration

    def primes_iter(self, number=None):
        return self._iter_ideals(True,number)

    def ideals_iter(self, number=None):
        return self._iter_ideals(False,number)

    def ideal_label(self, idl):
        try:
            return self.label_dict[idl]
        except KeyError:
            print("Unable to find label for ideal %s" % idl)
            return None

    def ideal(self, lab):
        try:
            return self.ideal_dict[lab]
        except KeyError:
            print("Unable to find ideal for label %s" % idl)
            return None

    def prime_label(self, idl):
        return self.ideal_label(idl)

    def prime_index(self, idl):
        try:
            return self.prime_index_dict[idl]
        except KeyError:
            print("Unable to find index of prime %s" % idl)
            return None

    def ideal_index(self, idl):
        try:
            return self.ideal_index_dict[idl]
        except KeyError:
            print("Unable to find index of ideal %s" % idl)
            return None

    def prime(self, lab):
        return self.ideal(lab)

    def init_from_file(self, filename):
        print("Creating HilbertNumberField from file %s" % filename)
        hmff = file(filename)
        if not hmff:
            raise ValueError("Could not open file %s" % filename)
        for L in hmff.readlines():
            if "NEWFORMS" in L:
                # For the field we need read no further
                break

            if "COEFFS" in L and not "NumberField" in L:
                coeffs = [int(c) for c in L[L.find("[")+1:L.find("]")].split(",")]
            if "n := " in L:
                deg = int(L[L.find("= ")+2:L.find(";")])

            if "d := " in L:
                disc = int(L[L.find("= ")+2:L.find(";")])
                # By the time d is read, we know enough to look up the
                # field in the fields database, using the signature
                # and decriminant (encoded), together with the
                # coefficient list (if there is more than one field
                # with the same signature and discrimimant)
                from lmfdb.number_fields.number_field import make_disc_key
                dkey = make_disc_key(ZZ(disc))[1]
                sig = "%s,%s" % (deg,0)
                co = str(coeffs)[1:-1].replace(" ","")
                print("Finding all fields with signature %s and disc_key %s ..." % (sig,dkey))
                self.label = None
                for f in fields.find({"disc_abs_key": dkey, "signature": sig}):
                    if f['coeffs'] == co:
                        self.label = f['label']
                        break

                if not self.label:
                    raise ValueError("Unable to find a field with signature %s, disc key %s and coeffs [%s] in the fields database!" % (sig, dkey, co))

                print("...found!")
                # We almost have enough now to contruct the
                # WebNumberField, but not quite: we need the
                # generator's name which we will find in the list of
                # primes.
                self.var = "?"

            if "PRIMES :=" in L:
                # convert one string into a list of strings
                L = L[L.find("[[")+1:L.find("]]")+1]
                self.primes = L.replace(" ","").replace("],[","] , [").split(" , ")
                #print("primes = %s" % self.primes)
                if self.var == "?":
                    self.var = findvar(self.primes)
                    print("variable name is %s (from PRIMES)" % self.var)

            if "LEVELS :=" in L:
                # convert one string into a list of strings
                L = L[L.find("[[")+1:L.find("]]")+1]
                self.ideals = L.replace(" ","").replace("],[","] , [").split(" , ")
                #print("ideals = %s" % self.ideals)
                if self.var == "?":
                    self.var = findvar(self.ideals)
                    print("variable name is %s (from LEVELS list)" % self.var)

        print("Initializing WebNumberField with label %s, name %s" % (self.label,self.var))
        WebNumberField.__init__(self,self.label,gen_name=self.var)
        self.ideal_dict = {}
        self.label_dict = {}
        for I in self.ideals_iter():
            self.ideal_dict[I['label']]=I['ideal']
            self.label_dict[I['ideal']]=I['label']

    def store_in_db(self):
        r""" Stores self in the database, using 'upsert' so there is no
        duplication but data is updated as necessary.

        An entry in the database has the following data fields:

        'label' (unicode string): label
        'degree' (int): degree
        'discriminant' (int): discrimimant
        'ideals' (list of unicode strings): integral ideals in order
        'primes' (list of unicode strings): prime ideals in order
        """
        db_data = {"label": self.label,
                   "degree": self.degree(),
                   "discriminant": int(self.disc()),
                   "ideals": self.ideals,
                   "primes": self.primes}
        db_hmfnf().update({'label': self.label}, {"$set": db_data}, upsert=True)

    def check_with_db(self):
        r""" Check that the data in self agrees with whatis in the database for
        the same label.
        """
        db_data = db_hmfnf().find_one({'label':self.label})
        if not db_data:
            print("HMF fields database has no entry with label %s" % self.label)
            return True

        if db_data['degree'] != self.degree():
            print("HMF field %s has degree %s but this has degree %s" % (self.label, db_data['degree'], self.degree()))
            return False

        if db_data['discriminant'] != self.disc():
            print("HMF field %s has discriminant %s but this has discriminant %s" % (self.label, db_data['discriminant'], self.disc()))
            return False

        # primes and ideals : we do not just compare strings but
        # actual ideals, also reporting on whether the numbers agree
        # (but this will not result in a failure):

        F = HilbertNumberField(self.label)
        from itertools import izip
        agree = True

        npdiff = False
        if len(db_data['primes']) != len(self.primes):
            npdiff = True
            print("HMF field %s has %s primes, but this has %s" % (self.label, len(db_data['primes']), len(self.primes)))
        else:
            print("HMF field %s has %s primes, agreed" % (self.label, len(db_data['primes'])))
        npbad = sum([P!=Q for P,Q in izip(F.primes_iter(),G.primes_iter())])
        if npbad:
            agree = False
            print("HMF field %s: inconsistent list of primes (%s disagreements)"% (self.label,npbad))
        else:
            if npdiff:
                print(" ...consistent lists of primes (the first %s agree)" % min(len(db_data['primes']),len(self.primes)))

        nidiff = False
        if len(db_data['ideals']) != len(self.ideals):
            nidiff = True
            print("HMF field %s has %s ideals, but this has %s" % (self.label, len(db_data['ideals']), len(self.ideals)))
        nibad = sum([P!=Q for P,Q in izip(F.ideals_iter(),G.ideals_iter())])
        if nibad:
            agree = False
            print("HMF field %s: inconsistent list of ideals (%s disagreements)"% (self.label,nibad))
        else:
            if nidiff:
                print(" ...consistent lists of ideals (the first %s agree)" % min(len(db_data['ideals']),len(self.ideals)))

        return agree
